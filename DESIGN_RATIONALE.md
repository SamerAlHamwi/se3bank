# Design Rationale Document

## 1. Factory Pattern (`AccountFactory`)

### **السبب والهدف**
استخدمنا **Factory Pattern** لمركزية منطق إنشاء أنواع الحسابات المختلفة (توفير، جاري، قروض، استثمار). عملية إنشاء الحساب تتطلب إعدادات أولية معقدة ومختلفة لكل نوع (مثل حدود السحب، معدلات الفائدة، أو شروط القرض).

### **البدائل**
*   **إنشاء مباشر (`new SavingsAccount()`):** يؤدي إلى تشتت منطق الإنشاء في كل مكان، وصعوبة في الصيانة عند إضافة أنواع جديدة أو تغيير منطق التهيئة.
*   **Static Factory Method:** جيد ولكن أقل مرونة في الاختبار (Mocking) مقارنة بـ Factory Class يمكن حقنها.

### **تحقيق المتطلبات**
يسمح `AccountFactory` باستقبال طلب إنشاء موحد (`CreateAccountRequest`) وإرجاع النوع المناسب مع تهيئة كافة الحقول الافتراضية بشكل صحيح دون أن يعرف العميل تفاصيل هذه التهيئة.

### **Trade-offs**
*   **الإيجابيات:** فصل مسؤولية الإنشاء عن الاستخدام، سهولة التوسع (Open/Closed Principle).
*   **السلبيات:** زيادة عدد الكلاسات قليلاً.

---

## 2. Strategy Pattern (`InterestCalculator` / `InterestStrategy`)

### **السبب والهدف**
الحسابات البنكية لها طرق متعددة لحساب الفائدة (بسيطة، مركبة، إسلامية/بدون فائدة). **Strategy Pattern** يسمح بتغيير خوارزمية حساب الفائدة في وقت التشغيل دون تعديل كلاسات الحسابات نفسها.

### **البدائل**
*   **جمل شرطية (`if-else` أو `switch`) داخل كلاس `Account`:** تجعل الكود طويلاً، صعب القراءة، وتخرق مبدأ المسؤولية الواحدة (SRP).
*   **الوراثة (Subclassing):** قد نضطر لتكرار كود الفائدة إذا اشتركت أنواع حسابات مختلفة (مثل توفير واستثمار) في نفس طريقة الحساب.

### **تحقيق المتطلبات**
واجهة `InterestStrategy` تعرف طريقة `calculateInterest`، ولدينا تطبيقات مثل `SimpleInterestStrategy` و `CompoundInterestStrategy`. يمكن لكل حساب أن يمتلك استراتيجية مختلفة، مما يسهل إضافة منتجات بنكية جديدة بقواعد فائدة مخصصة.

### **Trade-offs**
*   **الإيجابيات:** سهولة تبديل الخوارزميات، إزالة الشروط المعقدة.
*   **السلبيات:** زيادة عدد الكائنات في الذاكرة (لكل استراتيجية كلاس).

---

## 3. Decorator Pattern (`AccountDecorator`)

### **السبب والهدف**
نحتاج لإضافة ميزات إضافية للحسابات بشكل ديناميكي (مثل التأمين، حماية السحب المكشوف، خدمات مميزة) دون التأثير على الحسابات الأخرى أو تعديل الكلاس الأصلي. **Decorator Pattern** هو الحل الأمثل لذلك.

### **البدائل**
*   **الوراثة (Inheritance):** ستؤدي إلى "انفجار" في عدد الكلاسات (مثل `SavingsWithInsurance`, `SavingsWithOverdraft`, `SavingsWithBoth`...).
*   **حقول boolean في كلاس `Account`:** تجعل الكلاس ضخماً وغير مرن لإضافة ميزات مستقبلية غير متوقعة.

### **تحقيق المتطلبات**
يسمح `AccountDecorator` (مثل `InsuranceDecorator`) بتغليف كائن `Account` وإضافة سلوك جديد (مثل خصم رسوم شهرية إضافية أو التحقق من شروط خاصة) مع الحفاظ على واجهة `Account` الأصلية.

### **Trade-offs**
*   **الإيجابيات:** مرونة عالية في تركيب الميزات (Mix and match).
*   **السلبيات:** قد يصبح تتبع سلسلة الكائنات (Decorators chain) معقداً أثناء التصحيح (Debugging).

---

## 4. Composite Pattern (`AccountGroup`)

### **السبب والهدف**
نحتاج للتعامل مع الحسابات الفردية ومجموعات الحسابات (مثل الحسابات العائلية أو الشركات) بنفس الطريقة. **Composite Pattern** يسمح بمعاملة "الجزء" (Account) و"الكل" (AccountGroup) عبر واجهة موحدة.

### **البدائل**
*   **معالجة المجموعات بشكل منفصل:** يتطلب كوداً خاصاً للتعامل مع القوائم (`List<Account>`) في كل مكان نحتاج فيه لحساب الرصيد الإجمالي أو تطبيق عمليات جماعية.

### **تحقيق المتطلبات**
كلاس `AccountGroup` يحتوي على قائمة من `Account` (التي قد تكون حسابات فردية أو مجموعات أخرى). عند طلب `getBalance()` للمجموعة، تقوم بجمع أرصدة أبنائها تلقائياً. يسهل هذا إدارة المحافظ الاستثمارية أو الحسابات المشتركة.

### **Trade-offs**
*   **الإيجابيات:** تبسيط الكود للعميل (Client) الذي يتعامل مع `Account` ولا يهتم إن كان فرداً أو مجموعة.
*   **السلبيات:** قد يجعل التصميم عاماً جداً، مما يصعب فرض قيود خاصة على "الأوراق" (Leaf nodes) فقط.

---

## 5. Facade Pattern (`BankFacade`)

### **السبب والهدف**
النظام يحتوي على أنظمة فرعية معقدة (خدمة الحسابات، المعاملات، الإشعارات، المستخدمين). **Facade Pattern** يوفر واجهة مبسطة وموحدة للعملاء (Controllers) لتنفيذ العمليات التجارية الكاملة مثل "فتح حساب" أو "تحويل أموال".

### **البدائل**
*   **استدعاء الخدمات مباشرة من الـ Controller:** يؤدي إلى تكرار منطق التنسيق (Business Logic Orchestration) في الـ Controllers، ويجعلها معتمدة بشكل كبير على تفاصيل الأنظمة الفرعية (Coupling عالي).

### **تحقيق المتطلبات**
`BankFacade` يغلف التعقيد. مثلاً، عملية `transferMoney` داخل الـ Facade تقوم بالتحقق من الرصيد، خصم المبلغ، إضافته للمستفيد، تسجيل المعاملة، وإرسال الإشعارات، كل ذلك في استدعاء واحد من الـ Controller.

### **Trade-offs**
*   **الإيجابيات:** تقليل الاعتمادية (Loose Coupling)، واجهة نظيفة وسهلة الاستخدام.
*   **السلبيات:** قد يتحول الـ Facade إلى "God Object" إذا وضعنا فيه كل منطق النظام؛ يجب الحذر وإبقاءه للتنسيق فقط.

---

## 6. Observer Pattern (`Notifications`)

### **السبب والهدف**
نحتاج لإعلام المستخدمين عند حدوث أحداث معينة (إيداع، سحب، دخول مشبوه) دون ربط كود المعاملات بكود الإشعارات بشكل صلب. **Observer Pattern** يحقق هذا الفصل.

### **البدائل**
*   **استدعاء خدمة الإشعارات مباشرة:** يجعل كود المعاملات معتمداً على تفاصيل الإرسال (إيميل، SMS)، ويصعب إضافة قنوات جديدة لاحقاً.
*   **Polling:** فحص دوري للتغييرات، وهو غير كفؤ ويهدر الموارد.

### **تحقيق المتطلبات**
عند حدوث حدث (مثلاً في `BankFacade`)، يتم إعلام جميع المراقبين (`NotificationObserver` مثل `EmailNotifier`, `SMSNotifier`). هذا يسمح بإضافة قنوات جديدة (مثل Push Notifications) دون تغيير سطر واحد في كود المعاملات المالية.

### **Trade-offs**
*   **الإيجابيات:** فك الارتباط (Decoupling)، دعم مبدأ Open/Closed.
*   **السلبيات:** ترتيب تنفيذ المراقبين غير مضمون، وصعوبة تتبع سير العمل إذا كثرت الأحداث.

---

## 7. Adapter Pattern (`PaymentGateway`)

### **السبب والهدف**
النظام يحتاج للتكامل مع بوابات دفع خارجية (Stripe, PayPal) التي تملك واجهات برمجية (APIs) مختلفة وغير متوافقة مع نظامنا الداخلي. **Adapter Pattern** يعمل كجسر لترجمة واجهتنا الموحدة إلى واجهة الطرف الثالث.

### **البدائل**
*   **تعديل كودنا ليتناسب مع كل بوابة:** غير عملي ويجعل النظام يعتمد على مكتبات خارجية متغيرة.
*   **كتابة كود مخصص لكل بوابة في الـ Service:** يؤدي إلى `if (provider == STRIPE) ... else if ...` مما يعقد الصيانة.

### **تحقيق المتطلبات**
أنشأنا واجهة `PaymentGateway` موحدة. ثم قمنا بعمل `PayPalAdapter` و `StripeAdapter` يطبقان هذه الواجهة ويحولان طلباتنا إلى الشكل الذي تفهمه `Stripe` أو `PayPal`. هذا يسمح بتبديل مزود الدفع بسهولة.

### **Trade-offs**
*   **الإيجابيات:** عزل النظام عن تغييرات المكتبات الخارجية، توحيد طريقة التعامل مع المدفوعات.
*   **السلبيات:** زيادة التعقيد بإضافة طبقة تحويل إضافية.
