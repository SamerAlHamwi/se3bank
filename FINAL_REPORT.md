# التقرير النهائي - نظام SE3 Bank

## 1. شرح النظام (System Overview)

نظام **SE3 Bank** هو منصة بنكية متكاملة تعتمد على معمارية الطبقات (Layered Architecture) وتستخدم إطار عمل Spring Boot. يوفر النظام واجهات برمجية (APIs) قوية وآمنة لإدارة جميع الجوانب البنكية بدءًا من إدارة المستخدمين والحسابات، مرورًا بالمعاملات المالية المعقدة، وصولاً إلى التكامل مع أنظمة الدفع الخارجية. تم تصميم النظام ليكون مرنًا، قابلاً للتوسع، وآمنًا من خلال التطبيق الدقيق لأنماط التصميم (Design Patterns).

### الوحدات الوظيفية والمتحكمات (Detailed Modules & Controllers)

يتم تقسيم النظام إلى وحدات منطقية (Modules)، كل وحدة مسؤولة عن مجال عمل محدد وتتواصل مع العالم الخارجي عبر مجموعة من الـ Controllers.

#### 1. وحدة الأمان وإدارة الهوية (`Security & Identity Module`)
هذه الوحدة هي بوابة الدخول للنظام، وتضمن أن المستخدمين المصرح لهم فقط يمكنهم الوصول إلى البيانات والوظائف.

*   **المتحكم الرئيسي:** `AuthController`
    *   **نقطة النهاية `/auth/register` (POST):**
        *   **الوظيفة:** تسجيل مستخدم جديد في النظام.
        *   **العملية:** تستقبل بيانات المستخدم (الاسم، البريد الإلكتروني، كلمة المرور)، تقوم بتشفير كلمة المرور باستخدام خوارزمية **BCrypt** القوية، وتحفظ المستخدم في قاعدة البيانات. بمجرد التسجيل بنجاح، يتم إصدار رمز وصول (JWT Token) تلقائيًا للمستخدم لبدء استخدامه فوراً.
    *   **نقطة النهاية `/auth/login` (POST):**
        *   **الوظيفة:** مصادقة المستخدمين الحاليين.
        *   **العملية:** تتحقق من صحة بيانات الاعتماد. في حال المطابقة، يتم توليد **JWT (JSON Web Token)** يحتوي على هوية المستخدم وصلاحياته. يجب إرسال هذا الرمز في ترويسة (Header) كل طلب لاحق (`Authorization: Bearer <token>`) لتعريف المستخدم.
    *   **نقطة النهاية `/auth/me` (GET):**
        *   **الوظيفة:** استرجاع بيانات المستخدم الحالي بناءً على الرمز المرسل.

#### 2. وحدة إدارة المستخدمين (`User Management Module`)
*   **المتحكم:** `UserController`
    *   **الوظيفة:** إدارة ملفات تعريف المستخدمين.
    *   **العمليات:** تحديث البيانات الشخصية، عرض الملف الشخصي، والتعامل مع إعدادات المستخدم.

#### 3. وحدة إدارة الحسابات (`Accounts Management Module`)
جوهر النظام البنكي، حيث يتم إدارة دورة حياة الحسابات البنكية ومجموعات الحسابات.

*   **المتحكم:** `AccountController`
    *   **الوظيفة:** إدارة العمليات المباشرة على الحسابات الفردية.
    *   **العمليات:**
        *   إنشاء حسابات جديدة بأنواع متعددة (توفير، جاري) باستخدام نمط **Factory Pattern**، مما يسمح بإضافة أنواع جديدة مستقبلاً بسهولة.
        *   الاستعلام عن تفاصيل حساب معين (الرصيد، المالك، تاريخ الإنشاء).
        *   تحديث حالة الحساب (تجميد، تنشيط).
*   **المتحكم:** `GroupController`
    *   **الوظيفة:** تطبيق نمط **Composite Pattern** للسماح بإنشاء هياكل هرمية للحسابات.
    *   **السيناريو:** يمكن لرب الأسرة إنشاء "مجموعة العائلة" وإضافة حسابات أفراد الأسرة إليها، أو يمكن لشركة إنشاء مجموعة لكل قسم.
    *   **العمليات:**
        *   إنشاء مجموعة حسابات جديدة.
        *   إضافة حساب فردي (أو مجموعة فرعية) إلى مجموعة قائمة.
        *   الحصول على الرصيد الإجمالي للمجموعة (حيث يقوم النظام بجمع أرصدة كل الحسابات الفرعية تلقائيًا).
*   **المتحكم:** `DecoratorController`
    *   **الوظيفة:** تطبيق نمط **Decorator Pattern** لإضافة ميزات ديناميكية للحسابات.
    *   **السيناريو:** عميل يريد إضافة ميزة "حماية السحب على المكشوف" لحسابه الجاري. بدلاً من إنشاء نوع حساب جديد، يتم "تزيين" الحساب الحالي بهذه الميزة.
    *   **العمليات:** إضافة ميزات مثل (بطاقات ائتمان، برامج ولاء، حماية من السحب الزائد) لأي حساب قائم.

#### 4. وحدة المعاملات المالية (`Transactions Engine`)
المحرك الذي ينفذ حركات الأموال ويضمن سلامتها وتوافقها مع القوانين.

*   **المتحكم:** `TransactionController`
    *   **الوظيفة:** تنفيذ عمليات النقل المالي المباشرة والاستعلام عنها.
    *   **العمليات:**
        *   **`createTransaction`:** بدء معاملة جديدة (إيداع، سحب، تحويل).
        *   **`getTransactionHistory`:** استرجاع سجل المعاملات لحساب معين مع إمكانية الفلترة حسب التاريخ أو النوع.
        *   **`getTransactionDetails`:** الحصول على تفاصيل دقيقة لمعاملة محددة.
    *   **آلية المعالجة (Chain of Responsibility):** يتم تمرير طلب المعاملة عبر سلسلة من المعالجات (Handlers) للتحقق: `LimitCheck` -> `BalanceCheck` -> `FraudDetection` -> `AMLCompliance`.

#### 5. الواجهة الموحدة للخدمات (`Facade Module`)
طبقة تبسيطية تجعل التعامل مع النظام سهلاً للواجهات الأمامية (Frontend) وتطبيقات الهاتف.

*   **المتحكم:** `BankFacadeController`
    *   **الوظيفة:** تطبيق نمط **Facade Pattern**. بدلاً من أن يضطر تطبيق الموبايل لطلب 4 خدمات مختلفة لفتح حساب (تسجيل مستخدم -> إنشاء حساب -> تفعيل إشعارات -> إيداع أولي)، يطلب خدمة واحدة من الـ Facade.
    *   **الخدمات المركبة:**
        *   **`openNewAccount`:** تقوم بإنشاء المستخدم، الحساب، وربط الخدمات دفعة واحدة.
        *   **`transferMoney`:** تتأكد من الرصيد، تخصم من المرسل، تضيف للمستقبل، تسجل الحركة، وترسل إشعاراً للطرفين، كل ذلك في طلب واحد.
        *   **`getAccountSummary`:** تجمع بيانات الحساب، الرصيد، آخر المعاملات، والميزات النشطة في رد واحد شامل.

#### 6. وحدة الإشعارات (`Notifications Module`)
نظام للتواصل مع المستخدمين لإبقائهم على اطلاع دائم.

*   **المتحكم:** `NotificationController`
    *   **الوظيفة:** إدارة وعرض التنبيهات للمستخدمين.
    *   **العمليات:**
        *   **`getUnreadNotifications`:** جلب الإشعارات الجديدة فقط.
        *   **`markAsRead`:** تحديث حالة الإشعار بأنه تمت قراءته.
        *   **`getAllNotifications`:** استعراض الأرشيف الكامل للتنبيهات.
    *   **آلية العمل (Observer Pattern):** عندما يحدث حدث مهم (مثل إيداع)، يقوم `NotificationPublisher` (Subject) بإبلاغ جميع الـ Observers المسجلين، الذين يقومون بإنشاء الإشعارات وتخزينها ليتم استرجاعها عبر هذا المتحكم.

#### 7. وحدة الفوائد (`Interest Module`)
محرك حساب الأرباح والفوائد للحسابات.

*   **المتحكم:** `InterestController`
    *   **الوظيفة:** إدارة وحساب الفوائد للحسابات المختلفة.
    *   **العمليات:**
        *   **`calculateInterest`:** حساب قيمة الفائدة المستحقة لحساب معين بناءً على رصيده والمدة.
        *   **`applyInterest`:** إضافة الفائدة المحسوبة فعليًا لرصيد الحساب.
        *   **`changeStrategy`:** تغيير استراتيجية حساب الفائدة (Strategy Pattern) لحساب معين (مثلاً تحويله من فائدة ثابتة إلى متغيرة).

#### 8. وحدة المدفوعات والمحولات (`Payment Adapters`)
وحدة التكامل مع العالم الخارجي.

*   **المتحكم:** `PaymentController`
    *   **الوظيفة:** تمكين النظام من قبول مدفوعات من أنظمة خارجية (PayPal, Stripe) وإيداعها في حسابات العملاء.
    *   **العمليات:**
        *   **`processPayment`:** استقبال طلب دفع خارجي وتوجيهه للمحول المناسب.
    *   **آلية العمل (Adapter Pattern):** يستخدم النظام "محولات" (Adapters) لترجمة طلبات الدفع الخاصة بـ PayPal أو Stripe إلى تنسيق موحد يفهمه نظامنا البنكي الداخلي. هذا يعني أنه يمكننا إضافة طرق دفع جديدة (مثل Apple Pay) مستقبلاً بمجرد كتابة "محول" جديد دون تغيير كود النظام الأساسي.

---

## 2. أنماط التصميم بالتفصيل (Design Patterns Deep Dive)

تم اختيار وتطبيق أنماط التصميم (Design Patterns) في هذا المشروع ليس فقط كأفضل ممارسة، بل لحل تحديات تصميمية محددة واجهتنا أثناء التطوير:

### 1. Facade Pattern (الواجهة)
*   **المشكلة:** العمليات البنكية معقدة بطبيعتها. عملية بسيطة مثل "تحويل الأموال" تتطلب التفاعل مع خدمة الحسابات (للتحقق والخصم والإضافة)، خدمة المعاملات (للتسجيل)، وخدمة الإشعارات. ترك هذا التعقيد للـ Client (تطبيق الويب أو الموبايل) يؤدي لكود متشابك وصعب الصيانة.
*   **الحل (`BankFacade`):** قمنا بإنشاء فئة `BankFacade` تعمل كواجهة موحدة. الـ Controller يستدعي `bankFacade.transferMoney()` فقط، والـ Facade تتولى تنسيق العمل بين `AccountService`، `TransactionService`، و `NotificationService`.
*   **الفائدة:** تقليل الاعتمادية (Decoupling) بين الواجهة الأمامية والمنطق الخلفي المعقد، وسهولة الاستخدام.

### 2. Factory Pattern (المصنع)
*   **المشكلة:** لدينا أنواع متعددة من الحسابات (`SavingsAccount`, `CheckingAccount`). استخدام الكلمة المفتاحية `new` لإنشاء الكائنات مباشرة في الكود يجعل إضافة نوع حساب جديد (مثل "حساب استثماري") يتطلب تعديل الكود في أماكن متعددة.
*   **الحل (`AccountFactory`):** أنشأنا فئة `AccountFactory` بداخلها دالة `createAccount(type)`. نمرر لها نوع الحساب المطلوب، وهي تعيد لنا الكائن المناسب.
*   **الفائدة:** عند إضافة نوع حساب جديد، نعدل فقط في الـ Factory، ولا يتأثر باقي النظام.

### 3. Strategy Pattern (الاستراتيجية)
*   **المشكلة:** طرق حساب الفائدة تختلف وتتغير. قد يكون لحساب التوفير فائدة ثابتة، ولحساب الوديعة فائدة مركبة، وقد نطلق عرضاً ترويجياً بفائدة متغيرة. تضمين كل هذه الخوارزميات داخل فئة الحساب (Account Class) سيجعلها ضخمة ومعقدة (مليئة بجمل `if-else`).
*   **الحل (`InterestStrategy`):** قمنا بتعريف واجهة `InterestStrategy` لها دالة `calculateInterest()`. ثم أنشأنا فئات لكل استراتيجية (`FixedInterestStrategy`, `CompoundInterestStrategy`). الحساب يمتلك مرجعاً للاستراتيجية وليس للكود نفسه.
*   **الفائدة:** إمكانية تغيير طريقة حساب الفائدة للحساب في وقت التشغيل (Runtime) بمجرد تغيير كائن الاستراتيجية.

### 4. Decorator Pattern (المُزيّن)
*   **المشكلة:** نريد إضافة ميزات اختيارية للحسابات، مثل "بطاقة ائتمان" أو "تنبيهات SMS". الوراثة التقليدية (Inheritance) ستؤدي لانفجار في عدد الفئات (مثلاً: `SavingsAccountWithCreditCard`, `SavingsAccountWithSMS`, `SavingsAccountWithCreditCardAndSMS`...).
*   **الحل (`AccountDecorator`):** استخدمنا نمط الديكور. لدينا فئة أساسية `Account`، وفئات "مزينة" تغلف الحساب وتضيف له سلوكاً جديداً.
*   **الفائدة:** يمكننا تركيب الميزات بمرونة لا نهائية. حساب يمكن أن يغلف بـ "ديكور بطاقة ائتمان"، ثم الناتج يغلف بـ "ديكور تأمين"، وهكذا.

### 5. Composite Pattern (المركب)
*   **المشكلة:** الحاجة للتعامل مع حساب فردي ومجموعة حسابات بنفس الطريقة. مثلاً، نريد طلب `getBalance()` ويعمل سواء كان الهدف حساباً واحداً أو مجموعة عائلية (ليعيد مجموع الأرصدة).
*   **الحل (`AccountGroup`):** كل من الحساب الفردي ومجموعة الحسابات ينفذان نفس الواجهة. المجموعة تحتوي على قائمة من العناصر (التي قد تكون حسابات أو مجموعات أخرى). عند طلب الرصيد من المجموعة، تقوم هي بطلب الرصيد من كل أبنائها وجمعهم.
*   **الفائدة:** يبسط التعامل مع الهياكل الشجرية للحسابات بشكل كبير، حيث لا يحتاج العميل لمعرفة ما إذا كان يتعامل مع ورقة (حساب) أو عقدة (مجموعة).

### 6. Chain of Responsibility (سلسلة المسؤولية)
*   **المشكلة:** التحقق من صحة المعاملة المالية يتطلب خطوات كثيرة ومتتابعة (الرصيد، الحدود، الاحتيال، القوائم السوداء). وضع كل هذه الشروط في دالة واحدة (`if... else if...`) يجعل الكود طويلاً جداً وصعب القراءة والتعديل.
*   **الحل (`TransactionHandler`):** قمنا بإنشاء سلسلة من المعالجات. كل معالج يستلم الطلب، يقرر ما إذا كان سيعالجه، يرفضه، أو يمرره للمعالج التالي في السلسلة.
*   **الفائدة:** يمكننا إضافة خطوة تحقق جديدة (مثلاً: "التحقق من الموقع الجغرافي") ببساطة عن طريق إنشاء Handler جديد وإضافته للسلسلة دون لمس المعالجات الأخرى.

### 7. Adapter Pattern (المحول)
*   **المشكلة:** نريد دعم الدفع عبر PayPal و Stripe، لكن الـ API الخاص بكل منهما مختلف تماماً. لا نريد أن يتلوث كود نظامنا الداخلي بتفاصيل هذه الـ APIs الخارجية.
*   **الحل (`PaymentGatewayAdapter`):** عرفنا واجهة داخلية `PaymentGateway`. ثم أنشأنا Adapters لكل خدمة خارجية (`PayPalAdapter`, `StripeAdapter`). المحول يأخذ طلبنا القياسي، ويحوله لما يفهمه PayPal، ويعيد لنا النتيجة بتنسيقنا القياسي.
*   **الفائدة:** استقلال نظامنا عن تغييرات الأنظمة الخارجية، وسهولة دعم بوابات دفع جديدة.

### 8. Observer Pattern (المراقب)
*   **المشكلة:** أجزاء مختلفة من النظام تحتاج لرد فعل عند حدوث شيء ما (مثلاً عند إيداع راتب، يجب إرسال إشعار، وتحديث الإحصائيات، وربما تفعيل عرض ترويجي). ربط هذه الأجزاء ببعضها بشكل صلب (Hard-coded) يجعل النظام هشاً.
*   **الحل (`NotificationService` as Observer):** نستخدم نمط المراقب حيث تشترك المكونات المهتمة (Observers) في أحداث معينة (Subjects). عند حدوث الحدث، يتم إبلاغ جميع المشتركين تلقائياً.
*   **الفائدة:** فصل تام بين مُحدث الفعل (مثل نظام المعاملات) ومُستقبل الفعل (نظام الإشعارات).

---

## 3. التحديات التقنية وحلولها (Technical Challenges & Solutions)

أثناء بناء هذا النظام البنكي، واجهنا عدة تحديات جوهرية تتطلب حلولاً معمارية ذكية لضمان سلامة البيانات واستقرار النظام. فيما يلي أبرز التحديات وكيف تغلبنا عليها بالكود الحالي:

### 1. اتساق البيانات والعمليات المتزامنة (Concurrency & Data Consistency)
*   **التحدي:** في البيئة البنكية، الخطر الأكبر هو "الإنفاق المزدوج" (Double Spending) أو فقدان البيانات أثناء تحويل الأموال إذا حدث خطأ في منتصف العملية (مثلاً: تم الخصم من المرسل وفشل الإيداع للمستلم).
*   **الحل:**
    *   **إدارة المعاملات الذرية (`@Transactional`):** تم استخدام حاشية `@Transactional` بشكل مكثف في طبقة الـ `BankFacade` و `Service`. هذا يضمن خاصية **ACID**. إذا حدث أي استثناء (Exception) في أي خطوة من خطوات التحويل، يقوم النظام تلقائيًا بعمل **Rollback** لجميع التغييرات، لتعود الأرصدة كما كانت تماماً قبل بدء العملية.
    *   **Synchronization:** في الأجزاء الحساسة جداً من الذاكرة، تم تصميم الكود ليكون Thread-Safe.

### 2. تعقيد منطق التحقق من المعاملات (Complex Business Logic Validation)
*   **التحدي:** كل معاملة تتطلب عشرات التحققات (هل الرصيد كافٍ؟ هل الحساب نشط؟ هل المبلغ ضمن الحد اليومي؟ هل الدولة محظورة؟). كتابة هذه الشروط بشكل متداخل (Nested Ifs) يجعل الكود مستحيلاً للصيانة ومصدراً للأخطاء.
*   **الحل:** استخدام نمط **Chain of Responsibility**. تم تقسيم كل قاعدة عمل إلى `Handler` منفصل ومستقل (`BalanceCheckHandler`, `LimitCheckHandler`, etc.). هذا جعل الكود نظيفاً جداً، وسهل الاختبار (يمكن اختبار كل قاعدة على حدة)، وسهل التعديل (يمكن إعادة ترتيب القواعد أو إضافة قواعد جديدة دون لمس الكود القديم).

### 3. تكامل الأنظمة الخارجية غير المستقرة (Integration with Volatile External Systems)
*   **التحدي:** الاعتماد على بوابات دفع مثل PayPal و Stripe يعني التعامل مع APIs قد تتغير، وقد تتعطل، ولها صيغ بيانات مختلفة تماماً عن نظامنا الداخلي.
*   **الحل:** عزل النظام الداخلي تماماً باستخدام **Adapter Pattern**. النظام الداخلي لا يعرف شيئاً عن كائنات PayPal. هو يتعامل فقط مع واجهة `PaymentGateway`. الـ Adapter هو المسؤول الوحيد عن ترجمة البيانات والتعامل مع تعقيدات الطرف الثالث.

### 4. المرونة في إضافة الميزات الجديدة (Extensibility without Modification)
*   **التحدي:** طلبات العمل تتغير باستمرار (نريد إضافة نقاط ولاء، نريد إضافة رسوم إدارية للحسابات الجارية فقط، الخ). تعديل الكلاسات الأساسية (`Account`) لكل طلب جديد يخالف مبدأ **Open/Closed Principle**.
*   **الحل:** الاعتماد على **Decorator Pattern**. مكننا هذا من "تركيب" الميزات الجديدة كطبقات حول الحساب الأساسي في وقت التشغيل، مما حافظ على نظافة وثبات كود الحسابات الأساسية.

---

## 4. قابلية التوسع (Scalability)

تم تصميم النظام مع وضع النمو المستقبلي في الاعتبار، سواء من حيث عدد المستخدمين أو حجم البيانات:

### 1. التوسع الأفقي (Horizontal Scaling) عبر Stateless Architecture
يعتمد النظام في المصادقة على **JWT (JSON Web Tokens)**. هذا يعني أن السيرفر لا يحفظ حالة جلسة المستخدم (Stateless Session).
*   **الميزة:** يمكننا تشغيل النظام على 10 سيرفرات (أو حاويات Docker) خلف Load Balancer دون القلق بشأن "Sticky Sessions". أي طلب من أي مستخدم يمكن معالجته بواسطة أي سيرفر، مما يجعل توسيع البنية التحتية أمراً سهلاً وغير محدود.

### 2. التوسع في هيكلية البيانات (Data Structure Scalability)
استخدام **Composite Pattern** في المجموعات (`AccountGroup`) يسمح للنظام بالتعامل مع هياكل تنظيمية معقدة جداً دون تعقيد الكود. يمكن للنظام استيعاب شركة عملاقة لها آلاف الأقسام والحسابات الفرعية بنفس كفاءة تعامله مع حساب فردي، لأن الكود يعامل "الجزء" و "الكل" بنفس الطريقة.

### 3. التصميم المعياري (Modular Design)
استخدام **Dependency Injection (DI)** والاعتماد على الواجهات (Interfaces) بدلاً من التطبيق المباشر (Concrete Classes) يعني أن مكونات النظام مفككة الارتباط (Loosely Coupled). هذا يسمح لفرق تطوير متعددة بالعمل على أجزاء مختلفة من النظام (فريق للمدفوعات، فريق للحسابات) دون أن يتعارض عملهم، مما يسرع وتيرة التطوير مع كبر حجم المشروع.

---

## 5. تحسينات مستقبلية (Future Improvements)

بناءً على الأساس القوي الذي تم بناؤه، نخطط للتحسينات التالية:

1.  **الانتقال إلى البنية المجهرية (Microservices Migration):**
    *   بما أن النظام مصمم أصلاً كوحدات مفصولة (Modules)، فإن الخطوة التالية هي فصل هذه الوحدات (Accounts, Transactions, Notifications) إلى خدمات مستقلة (Microservices) تعمل كل منها في حاوية خاصة، وتتواصل عبر REST أو Message Broker.

2.  **معالجة الأحداث في الوقت الفعلي (Event-Driven Architecture):**
    *   استبدال التنفيذ المباشر للإشعارات (Observer Pattern الحالي) بنظام طوابير رسائل مثل **RabbitMQ** أو **Apache Kafka**. هذا سيضمن عدم ضياع الإشعارات حتى لو تعطلت خدمة الإرسال مؤقتاً، وسيسرع استجابة واجهات المستخدم.

3.  **الذكاء الاصطناعي لكشف الاحتيال (AI-Driven Fraud Detection):**
    *   تطوير `FraudDetectionHandler` الحالي (الذي يعتمد على قواعد ثابتة) ليستخدم نموذج تعلم آلي (Machine Learning Model) يحلل سلوك المستخدم ويكتشف الأنماط الشاذة بدقة أعلى.

4.  **دعم المصادقة الثنائية (2FA & OAuth2):**
    *   تعزيز الأمان بإضافة طبقة تحقق ثانية (SMS/Authenticator App) وتوفير إمكانية الدخول عبر Google/Facebook.

5.  **التوثيق التلقائي (Automated Documentation):**
    *   توسيع استخدام **Swagger/OpenAPI** ليشمل أمثلة حية لكل السيناريوهات، مما يسهل على مطوري الواجهات الأمامية والشركاء التكامل مع النظام.
